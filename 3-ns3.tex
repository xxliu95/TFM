\chapter{Network Simulator 3}
\label{sec:ns3}

The \textit{ns-3} simulator is an open, extensible discrete-event network simulator designed primarily 
for educational and network research purposes \cite{ns3}.

In summary, \textit{ns-3} provides models of how packet data networks work and operate, as well as a 
simulation engine that allows users to run simulation experiments. To do research that are 
more difficult or impossible to do with real systems, to examine system behavior in a highly 
controlled, reproducible setting, and to understand about how networks work.

\textit{ns-3} is a collection of modules that can be used together as well as with other software 
libraries. This tool works mainly at the command line on \textit{Linux} or \textit{MacOS} and with 
\textit{C++} and \textit{Python} programming languages and development tools.

\section{Getting Started}
\label{sec:ns3intro}

The prerequisites for the \textit{ns-3} release version 3.32 are the following tools:

\begin{table}[h]
  \centering
  \begin{tabular}{@{}ll@{}}
  \toprule
  Prerequisite & Package/version                             \\ \midrule 
  C++ compiler & \texttt{clang++} or \texttt{g++} (\texttt{g++} version 4.9 or greater) \\ 
  Python       & \texttt{python3}  version \textgreater{}= 3.5         \\ 
  Git          & any recent version                          \\ 
  tar          & any recent version                          \\ 
  bunzip2      & any recent version                          \\ \bottomrule
  \end{tabular}
  \caption{Prerequisites for ns-3}
\end{table}

Start by downloading the source archive from \href{https://www.nsnam.org/release/ns-allinone-3.32.tar.bz2}{nsnam}
or \href{https://gitlab.com/nsnam/ns-3-allinone.git}{gitlab}. Then build \textit{ns-3} with \texttt{build.py}:

\begin{lstlisting}[language=myshell,caption={Download and installation of ns-3}, captionpos=b]
  # Download from nsnam
  $ cd
  $ mkdir workspace
  $ cd workspace
  $ wget https://www.nsnam.org/release/ns-allinone-3.32.tar.bz2
  $ |\color{myblue}tar| xjf ns-allinone-3.32.tar.bz2
  $ cd ns-allinone-3.32
  # Building ns-3
  $ ./build.py --enable-examples --enable-tests
  # Running a script
  # Create or copy a script to the scratch directory
  $ cp examples/tutorial/first.cc scratch/myfirst.cc
  $ ./waf --run scratch/myfirst
\end{lstlisting}

\section{ns-3 Concepts}
\label{sec:ns3conc}
This section will go over several networking concepts that have a specific meaning in ns-3.

\begin{itemize}[topsep=0pt]
  \item[] \textbf{Node}: A \texttt{Node} in \textit{ns-3} is the basic computing device abstraction. 
  The \texttt{Node} class has methods for managing computing device representations in simulations.
  \item[] \textbf{Application}: A \textit{ns-3} application run on \textit{ns-3} \texttt{Nodes}. An 
  \texttt{Applicacion} is the basic abstraction for a user program that generates some simulated activity.  
  The \texttt{Application} class provides functions for controlling the representations of the simulated
  version of user-level applications.
  \item[] \textbf{Channel}: A \texttt{Channel} in \textit{ns-3} is an abstraction of the basic communication 
  subnetwork in which \texttt{Nodes} are connected in. It can be as simple as a wire or as complicated as a
  large Ethernet switch.
  \item[] \textbf{Net Device}: A \texttt{NetDevice} in \textit{ns-3} simulates a \textit{Network Interface Card (NIC)}
  and the software controlling the \textit{NIC}. A \texttt{NetDevice} is installed in a \texttt{Node} to allow 
  it to communicate over \texttt{Channels} with other \texttt{Nodes} in the simulation.
  \item[] \textbf{Helpers}: Helper objects are created to make some commun tasks easier. Such as connecting
  \texttt{NetDevices} to \texttt{Nodes}, \texttt{NetDevices} to \texttt{Channels}, assigning IP addresses, etc. 
\end{itemize}

\section{Logging Module}
Message logging is a basic feature for large softwares, and \textit{ns-3} is no different. \textit{ns-3} 
offer a complete module for message logging with configurable verbosity levels. This means that logging 
functions of specific components can be enabled and other can be disabled completely.

There are different levels of log messages of ascending verbosity defined in \textit{ns-3}:

\begin{itemize}[topsep=0pt]
  \item \textbf{\texttt{LOG\_ERROR}}: For error messages (associated function: \texttt{NS\_LOG\_ERROR}).
  \item \textbf{\texttt{LOG\_WARN}}: For warning messages (associated function: \texttt{NS\_LOG\_WARN}).
  \item \textbf{\texttt{LOG\_DEBUG}}: For relatively rare, ad-hoc debugging messages (associated function: \texttt{NS\_LOG\_DEBUG}).
  \item \textbf{\texttt{LOG\_INFO}}: For informational messages about program progress (associated function: \texttt{NS\_LOG\_INFO}).
  \item \textbf{\texttt{LOG\_FUNCTION}}: For messages describing each function called (two associated function: \texttt{NS\_LOG\_FUNCTION}
  used for member functions, and \texttt{NS\_LOG\_FUNCTION\_NOARGS}, used for static functions)).
  \item \textbf{\texttt{LOG\_LOGIC}}: For messages describing logical flow within a function (associated function: \texttt{NS\_LOG\_LOGIC}).
  \item \textbf{\texttt{LOG\_ALL}}: Log everything mentioned above (no associated function).
\end{itemize}

To enable all logs, it is as simple as modifying a shell variable. In the next example the logging for the class
\texttt{UdpEchoClientApplication} and \texttt{UdpEchoServerApplication} is enabled with all levels, the time 
and the function prefixes:

\begin{lstlisting}[escapechar=@, language=myshell,caption={Enabling logging in ns-3}, captionpos=b]
  $ export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:UdpEchoServerApplication=level_all|prefix_func|prefix_time'
\end{lstlisting}

To disable logging simply type:

\begin{lstlisting}[escapechar=@, language=myshell,caption={Disabling logging in ns-3}, captionpos=b]
  $ export NS_LOG=
\end{lstlisting}

For more information with the logging modure see \cite{ns3}.

\section{Command Line Arguments}
There are local and global variables that can be changed in the command line without
editing the scripts. An example of a command could be like this:

\begin{lstlisting}[escapechar=@, language=myshell,caption={Command line arguments}, captionpos=b]
  # To check help 
  $ ./waf --run "scratch/myfirst --PrintHelp"
  # To check variables for PointToPointNetDevice
  $ ./waf --run "scratch/myfirst --PrintAttributes=ns3::PointToPointNetDevice"
  # We set the Datarate to 5Mbps
  $ ./waf --run "scratch/myfirst --ns3::PointToPointNetDevice::DataRate=5Mbps"
\end{lstlisting}

\section{Tracing System}
The main goal of the simulations is to extract and generate output, and \textit{ns-3} offers two
mechanisms for this. Also, since \textit{ns-3} is a C++ software, using \texttt{std::cout} for
output is also available.

\subsection{ASCII Tracing}
ns-3 includes helper function that encapsulates the low-level tracing system and guides you 
through the technicalities of establishing some simple packet traces. If you enable this feature, 
the output will be in ASCII files, hence the name.

To enable ASCII Tracing, right before the call to \texttt{Simulator::Run ()}, add the following lines
of code:

\begin{lstlisting}[escapechar=@, language=myC++,caption={ASCII Tracing}, captionpos=b]
  AsciiTraceHelper ascii;
  pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("out.tr"));
\end{lstlisting}

This will generate the output from \texttt{pointToPoint} to a file named \texttt{out.tr}.

\subsection{PCAP Tracing}
The ns-3 device helpers can also create \texttt{.pcap} trace files. The \textit{pcap} file
contains the packets captured during the simulation. \textit{Wireshark} or \textit{tcpdump} 
are programs capable of reading and visualizing \textit{pcap} files.

To enable \textit{pcap} tracing simply add:
\begin{lstlisting}[escapechar=@, language=myC++,caption={PCAP Tracing}, captionpos=b]
  pointToPoint.EnablePcapAll ("myfirst");
\end{lstlisting}

This will create various \texttt{.pcap} files in the format \texttt{"myfirst-0-0.pcap"}, meaning
the trace file for node 0 and device 0.

\section{ns-3 Modules}

REM

MIMO

LTE enb phy

UM buffer size

TCP new reno?

Lossmodel

Fading loss model

Earfcn

Antenna model

Building